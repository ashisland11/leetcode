+ 用while遍历是不知道要循环几次,如果具体知道多少次--比如遍历这个string或者array的长度,就用for loop
+ 关注最优解 时间复杂度最低
+ non-decrasing包括相等和大于---sorted,order是升序
+  "add by one" 就是“每个值加 1”的意思
+  elif 是 "else if" 的缩写，表示“否则，如果...”。当 if 条件不成立时，它会检查 elif 后面的条件是否成立。
+  else 是指“否则”。当上面的所有条件都不成立时执行 else 块的代码。
+  continue 不是跳出整个循环，而是跳过当前循环的剩余部分，直接进入下一次循环。它的作用是在满足特定条件时，跳过当前的逻辑，而不退出整个循环。
  eg: for i in range(5):
    if i == 2:
        continue
    print(i)
0 
1
3
4
+ list.sort() 是一个就地排序方法，不会返回排序后的列表，而是直接修改原列表。这样写会导致 nums 的值变成 None. 排序直接写list.sort()
+ 在 Python 中，float('inf') 用来表示一个无限大的浮点数 float('-inf') 表示负无限大  ---infinite
+ 创建一个空的列表作为栈
+ stack = [] 先进后出
+ push 操作：添加元素到栈顶
+ stack.append(10)
+ stack.pop
+ . —— 表示当前目录。 
.. —— 表示父目录，也就是当前目录的上一级目录。  ".."就表示要回到上一级目录 如果碰到这个就代表要往上跳一级   /a/b/./../c==>/a/c
+ parts = ['home', 'user', 'documents', 'file.txt']
+path = '/'.join(parts)
+ 查看栈顶元素: stack[-1] 栈底元素:stack[0]
+ stack: append, pop
+ 在Python中，当使用负数进行除法时，结果向零取整的方式与C++或Java不同。Python中使用的是向负无穷取整，因此需要特别处理，使结果总是向零取整。可以通过使用int(a / b)来实现。
###Linked List
+ 链表中的快慢指针法:给定一个快指针和慢指针,快指针每次移动两步,慢指针每次移动一步. 如果没有环的话,快指针会到达终点None,如果是一个环,快指针和慢指针总会在环中的某一个点相遇
+ list.val是链表的头结点
+ 只要递归调用完成后，就会自动回溯，这一点是递归的重要特性！递归的每一步都依赖于之前的返回值，当递归调用达到终止条件时，程序会逐层返回，把结果传递给上一层，直到回到最初的调用位置。递归的回溯过程是为了逐步构建最终的结果链表,
+ 递归调用 会将当前状态保存到调用栈中，并进入下一层递归。
回溯 是递归完成后的必然过程，用来逐层返回结果并完成结构的连接。
每一层递归都依赖于子问题的返回值，回溯过程逐步构建最终的结果。
所以，递归函数只要有嵌套调用，就必然会回溯。
+ // 是整除，直接舍弃小数部分，仅保留商的整数部分：
+ linkedlist: 记住排除链表长度可能为0的情况
+ linked list核心是找到链表的头和尾巴




















