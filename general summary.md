+ 用while遍历是不知道要循环几次,如果具体知道多少次--比如遍历这个string或者array的长度,就用for loop
+ 关注最优解 时间复杂度最低
+ non-decrasing包括相等和大于---sorted,order是升序
+  "add by one" 就是“每个值加 1”的意思
+  elif 是 "else if" 的缩写，表示“否则，如果...”。当 if 条件不成立时，它会检查 elif 后面的条件是否成立。
+  else 是指“否则”。当上面的所有条件都不成立时执行 else 块的代码。
+  continue 不是跳出整个循环，而是跳过当前循环的剩余部分，直接进入下一次循环。它的作用是在满足特定条件时，跳过当前的逻辑，而不退出整个循环。
  eg: for i in range(5):
    if i == 2:
        continue
    print(i)
0 
1
3
4
+ list.sort() 是一个就地排序方法，不会返回排序后的列表，而是直接修改原列表。这样写会导致 nums 的值变成 None. 排序直接写list.sort()
+ 在 Python 中，float('inf') 用来表示一个无限大的浮点数 float('-inf') 表示负无限大  ---infinite
+ 创建一个空的列表作为栈
+ stack = [] 先进后出
+ push 操作：添加元素到栈顶
+ stack.append(10)
+ stack.pop
+ . —— 表示当前目录。 
.. —— 表示父目录，也就是当前目录的上一级目录。  ".."就表示要回到上一级目录 如果碰到这个就代表要往上跳一级   /a/b/./../c==>/a/c
+ parts = ['home', 'user', 'documents', 'file.txt']
+path = '/'.join(parts)
+ 查看栈顶元素: stack[-1] 栈底元素:stack[0]
+ stack: append, pop
+ 在Python中，当使用负数进行除法时，结果向零取整的方式与C++或Java不同。Python中使用的是向负无穷取整，因此需要特别处理，使结果总是向零取整。可以通过使用int(a / b)来实现。
###Linked List
+ 链表中的快慢指针法:给定一个快指针和慢指针,快指针每次移动两步,慢指针每次移动一步. 如果没有环的话,快指针会到达终点None,如果是一个环,快指针和慢指针总会在环中的某一个点相遇
+ list.val是链表的头结点
+ 只要递归调用完成后，就会自动回溯，这一点是递归的重要特性！递归的每一步都依赖于之前的返回值，当递归调用达到终止条件时，程序会逐层返回，把结果传递给上一层，直到回到最初的调用位置。递归的回溯过程是为了逐步构建最终的结果链表,
+ 递归调用 会将当前状态保存到调用栈中，并进入下一层递归。
回溯 是递归完成后的必然过程，用来逐层返回结果并完成结构的连接。
每一层递归都依赖于子问题的返回值，回溯过程逐步构建最终的结果。
所以，递归函数只要有嵌套调用，就必然会回溯。
+ // 是整除，直接舍弃小数部分，仅保留商的整数部分：
+ ###链表
  ```
  + 双向链表:
    插入操作：可以在链表的任意位置插入一个节点。通过修改相邻节点的next和prev指针，插入的节点就可以与其他节点连接。
    删除操作：删除节点时，需要调整相邻节点的next和prev指针，以断开与被删除节点的联系。
    遍历操作：可以从头到尾或从尾到头进行遍历。由于双向链表的每个节点都有前后指针，遍历时非常灵活。
+ linkedlist: 记住排除链表长度可能为0的情况
+ linked list核心是找到链表的头和尾巴
+ <img width="690" alt="image" src="https://github.com/user-attachments/assets/6082c954-6e24-4e8b-817c-b167fdb0e7c2" />
  ```
  在 Python 中，使用 __slots__ 是一种优化方式，用于限制类实例能够动态创建的属性。它通过指定固定的属性集合，减少了内存开销，同时加快了属性访问的速度。
  
  作用解释：
  限制动态添加属性：
  
  在 Python 中，普通类的实例存储属性时，会使用一个动态的字典（__dict__）。如果类定义了 __slots__，实例就不能再动态地添加未在 __slots__ 中定义的属性。
  内存优化：
  
  __slots__ 可以节省每个实例存储 __dict__ 的内存开销，尤其在需要创建大量对象的场景中很有用。
  更快的属性访问：
  
  因为属性是固定的，Python 不需要查找动态的字典，访问速度更快。
























