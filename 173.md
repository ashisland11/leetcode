这段代码通过栈的初始化，隐式地完成了“指针”的初始化：

栈的顶部始终是中序遍历的下一个节点。
初始化时，将左子树的所有节点压入栈，保证第一次调用 next() 返回最小值，从而满足题目要求。
3. 设计思想
使用栈来模拟递归调用，避免直接递归消耗额外空间。
栈保存的是当前节点及未访问的右子树信息，保证遍历按升序进行。
每次调用 next() 时，从栈中弹出最小值节点，同时对其右子树进行处理。
4. 具体实现步骤
初始化：

创建一个栈 stk 用于存储未访问的节点。
从根节点出发，将所有左子节点压入栈（使用辅助方法 pushLeftBranch）。
next() 方法：

弹出栈顶节点（当前的最小值）。
如果弹出的节点有右子树，调用 pushLeftBranch 方法，将右子树的所有左节点压入栈。
返回弹出节点的值。
hasNext() 方法：

检查栈是否为空。
如果栈中还有节点，说明还有未遍历的节点，返回 True；否则返回 False。
